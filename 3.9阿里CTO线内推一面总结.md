# 3.9阿里CTO线内推一面总结

tips1: java的知识默认你熟练JVM&JUC，必须好好掌握java虚拟机以及并发编程

tips2: 做场景题发现完全不可能做出来的时候尽早换题，避免尴尬

tips3: 八股文只知道是什么可不行，需要深入了解底层，并且自己尝试问自己可以**清晰表诉出来**



不会/不熟悉的知识为：

- ~~JVM~~

- ~~GC垃圾回收~~

- 并发编程

- 线程池

- 设计模式

下一轮面试3.14+，还有5days准备时间，现在是4days

准备内容如下：**JVM**，**并发编程**，设计模式基础，MySQL继续看重点，Spring框架（SSM+SpringBoot），**项目完全熟悉**，Linux基础，计网知识，**每天刷题**（数据结构和算法，shell



## 知识1：JVM的内存模型

![image-20220310003155593](https://gitee.com/geekpig/my-blog-images/raw/master/img/image-20220310003155593.png)

~~Q1:新生代，老年代，Eden，survivors是什么？~~

JVM的内存结构大概分为：

- 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。
- 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。
- 虚拟机栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。
- 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
- 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。

![image-20220310003934680](https://gitee.com/geekpig/my-blog-images/raw/master/img/image-20220310003934680.png)

### 堆

堆的作用是存放对象实例和数组。从结构上来分，可以分为新生代和老年代。而新生代又可以分为Eden 空间、From Survivor 空间（s0）、To Survivor 空间（s1）。 所有新生成的对象首先都是放在新生代的。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年代的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。

- 控制参数

-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最小空间大小。

- 垃圾回收

此区域是垃圾回收的主要操作区域。

- 异常情况

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常

### 方法区

方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。

很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。在Java8中永久代彻底消失了。

- 控制参数

-XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间。

- 垃圾回收

对此区域会涉及但是很少进行垃圾回收。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意。

- 异常情况

根据Java 虚拟机规范的规定， 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。

### 虚拟机栈

每个线程会有一个私有的栈。每个线程中方法的调用又会在本栈中创建一个栈帧。在方法栈中会存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

- 控制参数

-Xss控制每个线程栈的大小。

- 异常情况

在Java 虚拟机规范中，对这个区域规定了两种异常状况：

\- StackOverflowError： 异常线程请求的栈深度大于虚拟机所允许的深度时抛出；

\- OutOfMemoryError 异常： 虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出。

### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其

区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则

是为虚拟机使用到的Native 方法服务。

- 控制参数

在Sun JDK中本地方法栈和方法栈是同一个，因此也可以用-Xss控制每个线程的大小。

- 异常情况

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError

异常。

### 程序计数器

它的作用可以看做是当前线程所执行的字节码的行号指示器。

- 异常情况

此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。